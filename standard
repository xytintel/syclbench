#include <CL/sycl.hpp>
#include <iostream>
#include <random>
#include <vector>
#include <chrono>

double timeit(cl::sycl::event &event) {
    auto submit_time = event.get_profiling_info<cl::sycl::info::event_profiling::command_submit>();
    auto start_time = event.get_profiling_info<cl::sycl::info::event_profiling::command_start>();
    auto end_time = event.get_profiling_info<cl::sycl::info::event_profiling::command_end>();
    auto submission_time = (start_time - submit_time) / 1000000.0f;
    auto execution_time = (end_time - start_time) / 1000000.0f;
    return execution_time;
}

template <typename T, int vec_size>
struct alignas(sizeof(T) * vec_size) aligned_array {
    T val[vec_size];
};

template <typename in_t, typename out_t, int vec_size, typename item_t>
inline void dtype_cast_kernel(item_t &item, const in_t *in, out_t *out, const size_t n) {
    const int group_work_size = item.get_local_range(0) * vec_size;
    auto index = item.get_group(0) * group_work_size + item.get_local_id(0) * vec_size;
    auto remaining = n - index;
    if (remaining < vec_size) {
        for (auto i = index; i < n; i++) {
            out[i] = static_cast<out_t>(in[i]);
        }
    } else {
        using in_vec_t = aligned_array<in_t, vec_size>;
        using out_vec_t = aligned_array<out_t, vec_size>;
        auto in_vec = *reinterpret_cast<in_vec_t *>(const_cast<in_t *>(&in[index]));
        out_vec_t out_vec;
#pragma unroll
        for (int i = 0; i < vec_size; i++) {
            out_vec.val[i] = static_cast<out_t>(in_vec.val[i]);
        }
        *reinterpret_cast<out_vec_t *>(&out[index]) = out_vec;
    }
}

template <typename in_t, typename out_t, int vec_size>
float dtype_cast(sycl::queue &q, const in_t *in, out_t *out, size_t n) {
    const int group_size = 256;
    const int group_work_size = group_size * vec_size;
    auto event = q.submit([&](sycl::handler &h) {
        h.parallel_for(
            sycl::nd_range<1>(
                sycl::range<1>((n + group_work_size - 1) / group_work_size * group_size),
                sycl::range<1>(group_size)),
            [=](sycl::nd_item<1> item) {
                dtype_cast_kernel<in_t, out_t, vec_size>(item, in, out, n);
            });
    });
    event.wait();
    return timeit(event);
}

template <typename in_t, typename out_t, int vec_size>
void test_dtype_cast(sycl::queue &queue, size_t n) {
    auto in_cpu = new in_t[n];
    auto out_cpu = new out_t[n];
    for (int i = 0; i < n; i++)
        in_cpu[i] = static_cast<in_t>((float)rand() / (float)RAND_MAX);
    auto in_xpu = sycl::aligned_alloc_device<in_t>(256, n, queue);
    auto out_xpu = sycl::aligned_alloc_device<out_t>(256, n, queue);
    queue.memcpy(in_xpu, in_cpu, n * sizeof(in_t)).wait();
    float timems = dtype_cast<in_t, out_t, vec_size>(queue, in_xpu, out_xpu, n);
    float total_GBytes = (n * sizeof(in_t) + n * sizeof(out_t)) / 1000.0 / 1000.0;
    std::cout << timems << "ms " << total_GBytes / (timems) << " GBPS ... ";
    queue.memcpy(out_cpu, out_xpu, n * sizeof(out_t)).wait();
    auto maxdiff = -std::numeric_limits<float>::infinity();
    for (int i = 0; i < n; i++) {
        auto diff = std::abs((float)out_cpu[i] - (float)in_cpu[i]);
        maxdiff = std::max(maxdiff, diff);
    }
    std::cout << "maxdiff: " << maxdiff << std::endl;
    sycl::free(in_xpu, queue);
    sycl::free(out_xpu, queue);
    delete[] in_cpu;
    delete[] out_cpu;
}

int main() {
    sycl::queue queue(sycl::gpu_selector_v, cl::sycl::property_list{cl::sycl::property::queue::enable_profiling()});
    test_dtype_cast<float, sycl::half, 4>(queue, 4 * 4096);
    test_dtype_cast<float, sycl::half, 4>(queue, 4 * 4096);
    test_dtype_cast<float, sycl::half, 4>(queue, 4 * 4096);
    test_dtype_cast<float, sycl::half, 4>(queue, 4 * 4096 * 4096 + 3);
    test_dtype_cast<sycl::half, float, 4>(queue, 4 * 4096);
    test_dtype_cast<sycl::half, float, 4>(queue, 4 * 4096 * 4096);
    test_dtype_cast<sycl::half, float, 4>(queue, 4 * 4096 * 4096 + 3);
}
